<!DOCTYPE html>
<html lang="en-US">
    <head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Tom Leverstone">
<meta name="description" content="A father, software engineer, and hobbies collector. You may know me as Tom Gurion. Now it's Tom Leverstone.">
<title>Tom Leverstone</title>
<!-- Favicon -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- Bootstrap Core CSS -->
<link rel="stylesheet" href="/theme/css/bootstrap.min.css" type="text/css">
<!-- Custom Fonts -->
<link href='https://fonts.googleapis.com/css?family=Montserrat:300italic,400italic,700italic,300,400,700|Sen:700' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/theme/font-awesome/css/all.css" type="text/css">
<!-- Plugin CSS -->
<link rel="stylesheet" href="/theme/css/youtube.css" type="text/css">
<!-- Custom CSS -->
<link rel="stylesheet" href="/theme/css/creative.css" type="text/css">

<!-- Open graph protocol -->
<meta property="og:title" content="Tom Leverstone" />
<meta property="og:type" content="website" />
<meta property="og:url" content="" />
<meta property="og:image:secure_url" itemprop="image" content="/images/me.jpg" />
<meta property="og:description" content="A father, software engineer, and hobbies collector. You may know me as Tom Gurion. Now it's Tom Leverstone." />

<!-- Twitter cards -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="/images/me.jpg" />    </head>
    <body id="page-top">
    <!-- Header -->
    <section>
        <div class="container article-container">
<nav>
  <a class="btn btn-primary btn-home" href="/">
    <span class="fas fa-home"></span>
  </a>
  <ul>
    <li>
      <a class="btn" href="https://blog.leverstone.me">
        <span class="fa fa-blog"></span>
        &nbsp;Blog
      </a>
    </li>
    <li>
      <a class="btn" href="/today-i-learned"
        ><span class="fa fa-brain"></span>&nbsp;TIL</a
      >
    </li>
  </ul>
</nav>    <h1 class="title">Docker, compose, secrets, and environment variables</h1>
        <time datetime="2024-05-30">
            May 30, 2024
        </time>
    <div class="content">
        <!-- Content -->
        <p>A dockerised app I'm working on needs some secrets at build time. In my case, it needs to <code>pip install</code> from a private repository. Note that this is a generic problem, luckily with quite an elegant generic solution.</p>
<h1>How NOT to pass secrets to docker</h1>
<p>In the past, we solved this by passing a build argument with the secret.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># docker-compose.yml</span>
<span class="nt">services</span><span class="p">:</span>
<span class="w">  </span><span class="nt">my-app</span><span class="p">:</span>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span>
<span class="w">      </span><span class="nt">args</span><span class="p">:</span>
<span class="w">        </span><span class="nt">CONTAINER_SECRET</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;${HOST_SECRET}&quot;</span>
</code></pre></div>

<p>This is going to pass the <code>HOST_SECRET</code> environment variable from the host machine, to the container as an <code>ARG</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c"># Dockerfile</span>
<span class="k">ARG</span><span class="w"> </span>CONTAINER_SECRET
</code></pre></div>

<p><strong>Note</strong> that I'm calling these <code>CONTAINER_SECRET</code> and <code>HOST_SECRET</code> to make things easier to follow, but these will often have the same name. Up to you really.</p>
<p>There are two significant drawbacks to this approach:</p>
<ol>
<li>If the secret is a token that refreshes from time to time, it will mess up the docker build caching. In other words, when your token changes, every step after <code>ARG CONTAINER_SECRET</code> will have to be rerun during the build.</li>
<li>The secret can be extracted from the image, which is a security concern.</li>
</ol>
<h1>How to pass secrets to docker</h1>
<p>Luckily, <a href="https://docs.docker.com/build/building/secrets/">docker supports build secrets</a>. But until recently it was hard to fully utilize them because they were not supported by docker compose, which I almost always use for local development.</p>
<p>So, what are we trying to achieve?</p>
<ul>
<li>Call a command that requires a secret, stored in <code>HOST_SECRET</code> on the host, during the docker image build.</li>
<li>Use docker compose in local development to build the app.</li>
</ul>
<p>Let's start from the <code>Dockerfile</code>. It needs to call <code>pip install my-private-package</code> with our secret in the environment variable <code>CONTAINER_SECRET</code></p>
<div class="highlight"><pre><span></span><code><span class="c"># Dockerfile</span>
<span class="k">RUN</span><span class="w"> </span>--mount<span class="o">=</span><span class="nv">type</span><span class="o">=</span>secret,id<span class="o">=</span>my_secret<span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="nv">CONTAINER_SECRET</span><span class="o">=</span><span class="k">$(</span>cat<span class="w"> </span>/run/secrets/my_secret<span class="k">)</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>pip<span class="w"> </span>install<span class="w"> </span>my-private-package
</code></pre></div>

<p>The <code>Dockerfile</code> mounts the value of the secret called <code>my_secret</code> on <code>/run/secrets/my_secret</code>, which we load into an environment variable before calling the command. For security, the secret will only be accessbile during this <code>RUN</code> command. See <a href="https://docs.docker.com/build/building/secrets/">the docs</a> for more info about using secrets in docker builds.</p>
<p>Now let's have a look at the <code>docker-compose.yml</code></p>
<div class="highlight"><pre><span></span><code><span class="c1"># docker-compose.yml</span>
<span class="nt">services</span><span class="p">:</span>
<span class="w">  </span><span class="nt">my-app</span><span class="p">:</span>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">secrets</span><span class="p p-Indicator">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">my_secret</span>

<span class="nt">secrets</span><span class="p">:</span>
<span class="w">  </span><span class="nt">my_secret</span><span class="p">:</span>
<span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;HOST_SECRET&quot;</span>
</code></pre></div>

<p>The <code>docker-compose.yml</code> defines a global secret that is loaded from the environment variable <code>HOST_SECRET</code> on the host. There are other options for defining secrets (e.g. from a file). Again, consult <a href="https://docs.docker.com/compose/use-secrets/">the docs</a>. Then, the service that needs the secret can ask for it by name.</p>
<h1>Nice to haves</h1>
<h2>Build with docker</h2>
<p>While I mostly use docker compose for local development, sometimes it's useful to just build with docker, even for the same project! A good example is unit-tests. It's simple to build and run unit tests in the container without docker compose because there's no need for the surrounding services, environment variables, networking configuration, volumes, etc.</p>
<p>Here's how this is done</p>
<div class="highlight"><pre><span></span><code>docker build --secret id=my_secret,env=HOST_SECRET --tag my-app:test .
</code></pre></div>

<h2>Passing secrets to running containers</h2>
<p>Lastly, it's often useful to run commands that require secrets from within the container in development, not during the build. For example, when modifying dependencies (something like <code>pip install --upgrade my-private-package &amp;&amp; pip freeze &gt; requirements.txt</code>). In this case we need <code>CONTAINER_SECRET</code> in the container at runtime. A simple solution is to pass an environment variable to the container:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># docker-compose.yml</span>
<span class="nt">services</span><span class="p">:</span>
<span class="w">  </span><span class="nt">my-app</span><span class="p">:</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">environment</span><span class="p p-Indicator">:</span>
<span class="w">      </span><span class="nt">CONTAINER_SECRET</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">${ HOST_SECRET }</span>
</code></pre></div>

<p>While it's possible to use secrets at runtime there's no need to do so. Think about the two issues secrets solve: security and build time. The environment variable is not stored in the image so there's no security issue here. And the build is long done so there are no effect on that front either.</p>
        <!-- Links -->
    </div>
        </div>
    </section>

<!-- Bootstrap Core JavaScript -->
<script src="/theme/js/jquery.js"></script>
<script src="/theme/js/bootstrap.min.js"></script>    </body>
</html>